<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Agent Control Panel</title>
  <style>
    :root { color-scheme: light dark; font-family: system-ui, sans-serif; }
    body { 
      margin: 0; 
      padding: 0; 
      background: #0b0c10; 
      color: #e5e7eb; 
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    .header {
      padding: 16px;
      border-bottom: 1px solid #1f2937;
      background: #111827;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }
    
    h1 { 
      margin: 0; 
      font-size: 1.25rem; 
      flex: 1;
    }
    
    button { 
      padding: 10px 14px; 
      border-radius: 6px; 
      border: 1px solid #ef4444; 
      background: #991b1b; 
      color: #fff; 
      cursor: pointer; 
      font-weight: 600; 
      font-size: 0.9rem;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .status { 
      font-size: 0.9rem; 
      color: #9ca3af; 
    }
    
    .activity { 
      display: flex; 
      gap: 6px; 
      padding: 0 16px 12px 16px;
      flex-shrink: 0;
    }
    .segment { 
      flex: 1; 
      padding: 8px 6px; 
      text-align: center; 
      border-radius: 6px; 
      background: #0f172a; 
      border: 1px solid #1f2937; 
      color: #9ca3af; 
      font-weight: 600; 
      font-size: 0.85rem; 
    }
    .segment.active { 
      background: #2563eb; 
      color: #e5e7eb; 
      border-color: #1d4ed8; 
      box-shadow: 0 0 0 1px #1d4ed8 inset; 
    }
    
    .main-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }
    
    .history-panel {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .message {
      display: flex;
      flex-direction: column;
      max-width: 75%;
      animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .message.user {
      align-self: flex-end;
      align-items: flex-end;
    }
    
    .message.assistant {
      align-self: flex-start;
      align-items: flex-start;
    }
    
    .message-bubble {
      padding: 12px 16px;
      border-radius: 12px;
      word-wrap: break-word;
      white-space: pre-wrap;
      line-height: 1.5;
    }
    
    .message.user .message-bubble {
      background: #2563eb;
      color: #e5e7eb;
      border-bottom-right-radius: 4px;
    }
    
    .message.assistant .message-bubble {
      background: #1f2937;
      color: #e5e7eb;
      border-bottom-left-radius: 4px;
      border: 1px solid #374151;
    }
    
    .message-timestamp {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
      padding: 0 4px;
    }
    
    .live-panel {
      border-top: 1px solid #1f2937;
      background: #111827;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0;
    }
    
    .live-card {
      padding: 12px;
      border-radius: 8px;
      background: #0f172a;
      border: 1px solid #1f2937;
    }
    
    .live-label {
      font-weight: 600;
      margin-bottom: 8px;
      display: block;
      font-size: 0.9rem;
      color: #9ca3af;
    }
    
    .live-content {
      min-height: 60px;
      padding: 10px;
      border-radius: 6px;
      background: #0a0f1a;
      border: 1px solid #1f2937;
      white-space: pre-wrap;
      word-break: break-word;
      color: #e5e7eb;
    }
    
    .live-content:empty::before {
      content: 'Waiting...';
      color: #6b7280;
      font-style: italic;
    }
    
    .empty-history {
      text-align: center;
      color: #6b7280;
      padding: 40px 20px;
      font-style: italic;
    }
    
    .system-prompt-btn {
      padding: 10px 14px;
      border-radius: 6px;
      border: 1px solid #3b82f6;
      background: #1e40af;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .system-prompt-btn:hover {
      background: #2563eb;
    }
    
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal.active {
      display: flex;
    }
    
    .modal-content {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 24px;
      max-width: 800px;
      width: 90%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #1f2937;
      padding-bottom: 12px;
    }
    
    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #e5e7eb;
    }
    
    .modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }
    .modal-close:hover {
      background: #1f2937;
      color: #e5e7eb;
    }
    
    .modal-body {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .prompt-file-path {
      font-size: 0.85rem;
      color: #6b7280;
      font-family: monospace;
      padding: 8px;
      background: #0f172a;
      border-radius: 6px;
      border: 1px solid #1f2937;
    }
    
    .prompt-textarea {
      width: 100%;
      min-height: 300px;
      padding: 12px;
      background: #0f172a;
      border: 1px solid #1f2937;
      border-radius: 6px;
      color: #e5e7eb;
      font-family: monospace;
      font-size: 0.9rem;
      resize: vertical;
      box-sizing: border-box;
    }
    .prompt-textarea:focus {
      outline: none;
      border-color: #3b82f6;
    }
    
    .modal-footer {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #1f2937;
      padding-top: 12px;
    }
    
    .btn-primary {
      padding: 10px 20px;
      border-radius: 6px;
      border: 1px solid #3b82f6;
      background: #2563eb;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .btn-primary:hover:not(:disabled) {
      background: #1d4ed8;
    }
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-secondary {
      padding: 10px 20px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #1f2937;
      color: #e5e7eb;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .btn-secondary:hover {
      background: #374151;
    }
    
    .status-message {
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
    }
    .status-message.success {
      background: #065f46;
      color: #6ee7b7;
      border: 1px solid #047857;
      display: block;
    }
    .status-message.error {
      background: #7f1d1d;
      color: #fca5a5;
      border: 1px solid #991b1b;
      display: block;
    }

    /* Accordion Styles */
    .accordion {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .accordion-item {
      border: 1px solid #1f2937;
      border-radius: 8px;
      overflow: hidden;
      background: #0f172a;
    }
    .accordion-header {
      padding: 12px 16px;
      background: #1e293b;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      color: #e5e7eb;
      user-select: none;
    }
    .accordion-header:hover {
      background: #334155;
    }
    .accordion-header::after {
      content: '▼';
      font-size: 0.8rem;
      transition: transform 0.2s;
    }
    .accordion-item.active .accordion-header::after {
      transform: rotate(180deg);
    }
    .accordion-content {
      padding: 0;
      display: none;
      border-top: 1px solid #1f2937;
    }
    .accordion-item.active .accordion-content {
      display: block;
      padding: 16px;
    }
    
    /* Form Styles */
    .config-form-group {
      margin-bottom: 16px;
    }
    .config-label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .config-input {
      width: 100%;
      padding: 8px 12px;
      background: #111827;
      border: 1px solid #374151;
      border-radius: 6px;
      color: #e5e7eb;
      font-family: inherit;
      box-sizing: border-box;
    }
    .config-input:focus {
      outline: none;
      border-color: #3b82f6;
    }
    .config-checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .config-checkbox {
      width: 16px;
      height: 16px;
    }
    .config-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    .provider-section {
      border-left: 2px solid #3b82f6;
      padding-left: 12px;
      margin-top: 12px;
    }
    .nested-group {
      border: 1px solid #374151;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 12px;
      background: #111827;
    }
    .nested-title {
      font-size: 0.8rem;
      font-weight: 600;
      color: #6366f1;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Voice Agent Control Panel</h1>
    <button id="system-prompt-btn" class="system-prompt-btn">System Prompt</button>
    <button id="config-btn" class="system-prompt-btn">Config</button>
    <button id="toggle-listening-btn" class="system-prompt-btn">Stop Listening</button>
    <button id="cancel-btn">Cancel Speech</button>
    <span id="status" class="status">Connecting…</span>
  </div>
  
  <!-- System Prompt Modal -->
  <div id="system-prompt-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">System Prompt Editor</h2>
        <button class="modal-close" id="modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div>
          <span class="live-label">File Path:</span>
          <div id="prompt-file-path" class="prompt-file-path">Loading...</div>
        </div>
        <div>
          <span class="live-label">System Prompt:</span>
          <textarea id="prompt-textarea" class="prompt-textarea" placeholder="Enter system prompt..."></textarea>
        </div>
        <div id="status-message" class="status-message"></div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Hotkey Configuration Modal -->
  <div id="hotkey-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Hotkey Configuration</h2>
        <button class="modal-close" id="hotkey-modal-close">&times;</button>
      </div>
      <div class="modal-body">
        <div>
          <span class="live-label">Toggle Listening Hotkey:</span>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="text" id="hotkey-input" class="prompt-textarea" style="min-height: 40px; flex: 1;" placeholder="Press keys..." readonly />
            <button class="btn-secondary" id="hotkey-capture-btn">Capture</button>
          </div>
          <div style="font-size: 0.85rem; color: #6b7280; margin-top: 4px;">
            Current: <span id="current-hotkey-display">Loading...</span>
          </div>
        </div>
        <div id="hotkey-status-message" class="status-message"></div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" id="hotkey-modal-cancel">Cancel</button>
        <button class="btn-primary" id="hotkey-modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Configuration Modal -->
  <div id="config-modal" class="modal">
    <div class="modal-content" style="max-width: 900px; height: 90vh;">
      <div class="modal-header">
        <h2 class="modal-title">Configuration Editor</h2>
        <button class="modal-close" id="config-modal-close">&times;</button>
      </div>
      <div class="modal-body" style="overflow-y: auto;">
        <div id="config-accordion" class="accordion">
          <!-- Config sections will be injected here -->
        </div>
        <div id="config-status-message" class="status-message" style="margin-top: 16px;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" id="config-modal-cancel">Cancel</button>
        <button class="btn-primary" id="config-modal-save">Save Configuration</button>
      </div>
    </div>
  </div>

  <div class="activity" aria-label="Agent activity">
    <div id="seg-listening" class="segment">Listening</div>
    <div id="seg-transcribing" class="segment">Transcribing</div>
    <div id="seg-responding" class="segment">Responding</div>
    <div id="seg-synthesizing" class="segment">Synthesizing</div>
    <div id="seg-playing" class="segment">Playing</div>
  </div>

  <div class="main-container">
    <div id="history-panel" class="history-panel">
      <div class="empty-history">No conversation history yet</div>
    </div>

    <div class="live-panel">
      <div class="live-card">
        <span class="live-label">Current Transcript</span>
        <div id="current-transcript" class="live-content"></div>
      </div>
      <div class="live-card">
        <span class="live-label">Agent Response</span>
        <div id="current-response" class="live-content"></div>
      </div>
    </div>
  </div>

  <script>
    const historyPanel = document.getElementById('history-panel');
    const currentTranscript = document.getElementById('current-transcript');
    const currentResponse = document.getElementById('current-response');
    const statusEl = document.getElementById('status');
    const cancelBtn = document.getElementById('cancel-btn');
    const toggleListeningBtn = document.getElementById('toggle-listening-btn');
    const systemPromptBtn = document.getElementById('system-prompt-btn');
    const systemPromptModal = document.getElementById('system-prompt-modal');
    const modalClose = document.getElementById('modal-close');
    const modalCancel = document.getElementById('modal-cancel');
    const modalSave = document.getElementById('modal-save');
    const promptTextarea = document.getElementById('prompt-textarea');
    const promptFilePath = document.getElementById('prompt-file-path');
    const statusMessage = document.getElementById('status-message');
    
    // Config modal elements
    const configBtn = document.getElementById('config-btn');
    const configModal = document.getElementById('config-modal');
    const configModalClose = document.getElementById('config-modal-close');
    const configModalCancel = document.getElementById('config-modal-cancel');
    const configModalSave = document.getElementById('config-modal-save');
    const configAccordion = document.getElementById('config-accordion');
    const configStatusMessage = document.getElementById('config-status-message');

    let currentConfig = {};
    
    // Hotkey modal elements
    const hotkeyModal = document.getElementById('hotkey-modal');
    const hotkeyModalClose = document.getElementById('hotkey-modal-close');
    const hotkeyModalCancel = document.getElementById('hotkey-modal-cancel');
    const hotkeyModalSave = document.getElementById('hotkey-modal-save');
    const hotkeyInput = document.getElementById('hotkey-input');
    const hotkeyCaptureBtn = document.getElementById('hotkey-capture-btn');
    const currentHotkeyDisplay = document.getElementById('current-hotkey-display');
    const hotkeyStatusMessage = document.getElementById('hotkey-status-message');
    
    let currentHotkey = '';
    let isCapturingHotkey = false;
    let capturedKeys = [];
    const segments = {
      listening: document.getElementById('seg-listening'),
      transcribing: document.getElementById('seg-transcribing'),
      responding: document.getElementById('seg-responding'),
      synthesizing: document.getElementById('seg-synthesizing'),
      playing: document.getElementById('seg-playing'),
    };

    // State for current interaction
    let currentTranscriptText = '';
    let currentResponseText = '';
    let sttInterim = '';
    
    let activityState = {
      listening: true,
      transcribing: false,
      responding: false,
      synthesizing: false,
      playing: false,
    };

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function renderActivity(state) {
      activityState = { ...activityState, ...state };
      Object.entries(activityState).forEach(([key, isOn]) => {
        if (segments[key]) {
          segments[key].classList.toggle('active', !!isOn);
        }
      });
    }

    function formatTimestamp(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function renderHistoryMessage(message) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${message.role}`;
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = message.content;
      
      const timestamp = document.createElement('div');
      timestamp.className = 'message-timestamp';
      timestamp.textContent = formatTimestamp(message.timestamp);
      
      messageDiv.appendChild(bubble);
      messageDiv.appendChild(timestamp);
      
      return messageDiv;
    }

    function renderHistory(history) {
      // Clear empty message if present
      const emptyMsg = historyPanel.querySelector('.empty-history');
      if (emptyMsg) {
        emptyMsg.remove();
      }
      
      // Clear existing history
      historyPanel.innerHTML = '';
      
      if (!history || history.length === 0) {
        historyPanel.innerHTML = '<div class="empty-history">No conversation history yet</div>';
        return;
      }
      
      // Render all messages
      history.forEach(msg => {
        historyPanel.appendChild(renderHistoryMessage(msg));
      });
      
      // Scroll to bottom
      historyPanel.scrollTop = historyPanel.scrollHeight;
    }

    async function fetchHistory() {
      try {
        const response = await fetch('/ui/history');
        if (!response.ok) {
          console.error('Failed to fetch history');
          return;
        }
        const data = await response.json();
        if (data.history) {
          renderHistory(data.history);
        }
      } catch (e) {
        console.error('Error fetching history:', e);
      }
    }

    function updateCurrentTranscript() {
      const interimLine = sttInterim ? `\n[interim] ${sttInterim}` : '';
      currentTranscript.textContent = `${currentTranscriptText}${interimLine}`.trim() || '';
    }

    function updateCurrentResponse() {
      currentResponse.textContent = currentResponseText || '';
    }

    function clearLivePanel() {
      currentTranscriptText = '';
      sttInterim = '';
      currentResponseText = '';
      updateCurrentTranscript();
      updateCurrentResponse();
    }

    function commitCurrentTurn() {
      // Only commit if we have both transcript and response
      if (currentTranscriptText.trim() && currentResponseText.trim()) {
        // Reload history from server to get the latest (which includes the committed turn)
        fetchHistory();
      }
      clearLivePanel();
    }

    function connect() {
      const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
      const ws = new WebSocket(`${wsProto}://${location.host}/ui/events`);

      ws.onopen = () => {
        setStatus('Connected');
        // Fetch history when connected
        fetchHistory();
      };
      ws.onclose = () => {
        setStatus('Disconnected – retrying…');
        setTimeout(connect, 1500);
      };
      ws.onerror = () => setStatus('Error – retrying…');

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          switch (data.event) {
            case 'stt':
              if (data.stage === 'final') {
                // New final transcript - clear previous live state and start fresh
                currentTranscriptText = data.text || '';
                currentResponseText = '';
                sttInterim = '';
                updateCurrentResponse();
              } else if (data.stage === 'interim') {
                sttInterim = data.text || '';
              }
              updateCurrentTranscript();
              break;
            case 'llm_token':
              currentResponseText += data.token || '';
              updateCurrentResponse();
              break;
            case 'llm_done':
              setStatus('LLM complete');
              // Commit current turn to history
              commitCurrentTurn();
              break;
            case 'llm_cancelled':
              setStatus('LLM cancelled');
              clearLivePanel();
              break;
            case 'cancelled':
              setStatus('Speech cancelled');
              clearLivePanel();
              break;
            case 'activity':
              renderActivity(data.state || {});
              updateToggleListeningButton();
              break;
            case 'listening_state_changed':
              if (data.enabled !== undefined) {
                activityState.listening = data.enabled;
              }
              updateToggleListeningButton();
              break;
            case 'history_updated':
              // Refresh history when it's updated
              fetchHistory();
              break;
            case 'hotkey_registered':
              if (data.hotkey_id === 'toggle_listening') {
                currentHotkey = data.hotkey || '';
                updateHotkeyDisplay();
              }
              break;
            case 'hotkey_unregistered':
              if (data.hotkey_id === 'toggle_listening') {
                currentHotkey = '';
                updateHotkeyDisplay();
              }
              break;
            default:
              break;
          }
        } catch (e) {
          console.error('Bad message', e);
        }
      };
    }

    cancelBtn.onclick = async () => {
      cancelBtn.disabled = true;
      setStatus('Cancelling…');
      try {
        await fetch('/ui/cancel', { method: 'POST' });
      } finally {
        cancelBtn.disabled = false;
      }
    };

    // Toggle Listening Button
    toggleListeningBtn.onclick = async () => {
      toggleListeningBtn.disabled = true;
      try {
        const response = await fetch('/ui/listening/toggle', { method: 'POST' });
        if (!response.ok) {
          throw new Error('Failed to toggle listening');
        }
      } catch (e) {
        console.error('Error toggling listening:', e);
        setStatus('Error toggling listening');
      } finally {
        toggleListeningBtn.disabled = false;
      }
    };

    function updateToggleListeningButton() {
      const isListening = activityState.listening;
      toggleListeningBtn.textContent = isListening ? 'Stop Listening' : 'Start Listening';
      toggleListeningBtn.style.background = isListening ? '#1e40af' : '#991b1b';
      toggleListeningBtn.style.borderColor = isListening ? '#3b82f6' : '#ef4444';
    }

    // Hotkey Configuration
    async function loadHotkey() {
      try {
        const response = await fetch('/ui/hotkeys/toggle_listening');
        if (!response.ok) {
          throw new Error('Failed to load hotkey');
        }
        const data = await response.json();
        currentHotkey = data.hotkey || '';
        updateHotkeyDisplay();
      } catch (e) {
        console.error('Error loading hotkey:', e);
        currentHotkeyDisplay.textContent = 'Error loading';
      }
    }

    function updateHotkeyDisplay() {
      currentHotkeyDisplay.textContent = currentHotkey || 'Not set';
      hotkeyInput.value = currentHotkey || '';
    }

    function formatHotkeyString(keys) {
      const parts = [];
      if (keys.includes('ctrl') || keys.includes('control')) parts.push('Ctrl');
      if (keys.includes('shift')) parts.push('Shift');
      if (keys.includes('alt')) parts.push('Alt');
      if (keys.includes('meta') || keys.includes('cmd')) parts.push('Cmd');
      
      // Get the main key (not a modifier)
      const mainKey = keys.find(k => !['ctrl', 'control', 'shift', 'alt', 'meta', 'cmd'].includes(k));
      if (mainKey) {
        parts.push(mainKey.toUpperCase());
      }
      
      return parts.join('+');
    }

    function parseHotkeyString(hotkeyStr) {
      // Convert display format to API format
      return hotkeyStr.toLowerCase().replace(/\s+/g, '').replace(/\+/g, '+');
    }

    hotkeyCaptureBtn.onclick = () => {
      if (isCapturingHotkey) {
        // Stop capturing
        isCapturingHotkey = false;
        hotkeyCaptureBtn.textContent = 'Capture';
        hotkeyInput.placeholder = 'Press keys...';
        document.removeEventListener('keydown', captureHotkeyHandler);
      } else {
        // Start capturing
        isCapturingHotkey = true;
        hotkeyCaptureBtn.textContent = 'Stop';
        hotkeyInput.value = '';
        hotkeyInput.placeholder = 'Press your hotkey combination...';
        capturedKeys = [];
        document.addEventListener('keydown', captureHotkeyHandler, true);
      }
    };

    function captureHotkeyHandler(e) {
      e.preventDefault();
      e.stopPropagation();
      
      const keys = [];
      if (e.ctrlKey) keys.push('ctrl');
      if (e.shiftKey) keys.push('shift');
      if (e.altKey) keys.push('alt');
      if (e.metaKey) keys.push('meta');
      
      // Get the main key
      let mainKey = '';
      if (e.key.length === 1) {
        mainKey = e.key.toLowerCase();
      } else if (e.key.startsWith('F') && e.key.length <= 3) {
        mainKey = e.key.toLowerCase();
      } else {
        // Map special keys
        const keyMap = {
          ' ': 'space',
          'Enter': 'enter',
          'Tab': 'tab',
          'Escape': 'esc',
          'Backspace': 'backspace',
          'Delete': 'delete',
          'ArrowUp': 'up',
          'ArrowDown': 'down',
          'ArrowLeft': 'left',
          'ArrowRight': 'right',
        };
        mainKey = keyMap[e.key] || e.key.toLowerCase();
      }
      
      if (mainKey && !keys.includes(mainKey)) {
        keys.push(mainKey);
      }
      
      if (keys.length > 0) {
        capturedKeys = keys;
        const displayStr = formatHotkeyString(keys);
        hotkeyInput.value = displayStr;
        
        // Stop capturing after a short delay
        setTimeout(() => {
          isCapturingHotkey = false;
          hotkeyCaptureBtn.textContent = 'Capture';
          document.removeEventListener('keydown', captureHotkeyHandler);
        }, 500);
      }
    }

    toggleListeningBtn.oncontextmenu = async (e) => {
      e.preventDefault();
      hotkeyModal.classList.add('active');
      await loadHotkey();
    };

    function closeHotkeyModal() {
      hotkeyModal.classList.remove('active');
      isCapturingHotkey = false;
      hotkeyCaptureBtn.textContent = 'Capture';
      document.removeEventListener('keydown', captureHotkeyHandler);
      hotkeyStatusMessage.className = 'status-message';
    }

    hotkeyModalClose.onclick = closeHotkeyModal;
    hotkeyModalCancel.onclick = closeHotkeyModal;

    hotkeyModalSave.onclick = async () => {
      const hotkeyValue = hotkeyInput.value.trim();
      if (!hotkeyValue) {
        showHotkeyStatusMessage('Hotkey cannot be empty', true);
        return;
      }

      // Convert display format to API format
      const apiHotkey = parseHotkeyString(hotkeyValue);
      
      hotkeyModalSave.disabled = true;
      try {
        const response = await fetch('/ui/hotkeys/toggle_listening', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ hotkey: apiHotkey }),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to save hotkey');
        }

        showHotkeyStatusMessage('Hotkey saved successfully!');
        await loadHotkey();
        setTimeout(closeHotkeyModal, 1000);
      } catch (e) {
        console.error('Error saving hotkey:', e);
        showHotkeyStatusMessage(e.message || 'Failed to save hotkey', true);
      } finally {
        hotkeyModalSave.disabled = false;
      }
    };

    function showHotkeyStatusMessage(text, isError = false) {
      hotkeyStatusMessage.textContent = text;
      hotkeyStatusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
      setTimeout(() => {
        hotkeyStatusMessage.className = 'status-message';
      }, 3000);
    }

    // Close hotkey modal when clicking outside
    hotkeyModal.onclick = (e) => {
      if (e.target === hotkeyModal) {
        closeHotkeyModal();
      }
    };

    // Load non-realtime config (like hotkeys) on page load.
    // Realtime status (listening, activity, etc.) is driven by the WebSocket.
    async function loadConfig() {
      await loadHotkey();
      // Note: We no longer fetch /ui/listening/status here. 
      // The WebSocket handler in ui.py sends the initial state on connect.
    }

    loadConfig();

    // System Prompt Modal Functions
    function showStatusMessage(text, isError = false) {
      statusMessage.textContent = text;
      statusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
      setTimeout(() => {
        statusMessage.className = 'status-message';
      }, 3000);
    }

    async function loadSystemPrompt() {
      try {
        const response = await fetch('/ui/system-prompt');
        if (!response.ok) {
          throw new Error('Failed to load system prompt');
        }
        const data = await response.json();
        promptTextarea.value = data.prompt || '';
        promptFilePath.textContent = data.file_path || 'Unknown';
      } catch (e) {
        console.error('Error loading system prompt:', e);
        showStatusMessage('Failed to load system prompt', true);
      }
    }

    async function saveSystemPrompt() {
      const prompt = promptTextarea.value.trim();
      if (!prompt) {
        showStatusMessage('Prompt cannot be empty', true);
        return;
      }

      modalSave.disabled = true;
      try {
        const response = await fetch('/ui/system-prompt', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ prompt }),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to save system prompt');
        }

        const data = await response.json();
        showStatusMessage('System prompt saved successfully!');
        // Reload to get updated file path if needed
        await loadSystemPrompt();
      } catch (e) {
        console.error('Error saving system prompt:', e);
        showStatusMessage(e.message || 'Failed to save system prompt', true);
      } finally {
        modalSave.disabled = false;
      }
    }

    systemPromptBtn.onclick = async () => {
      systemPromptModal.classList.add('active');
      await loadSystemPrompt();
    };

    function closeModal() {
      systemPromptModal.classList.remove('active');
      statusMessage.className = 'status-message';
    }

    modalClose.onclick = closeModal;
    modalCancel.onclick = closeModal;
    modalSave.onclick = saveSystemPrompt;

    // Close modal on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && systemPromptModal.classList.contains('active')) {
        closeModal();
      }
    });

    // Close modal when clicking outside
    systemPromptModal.onclick = (e) => {
      if (e.target === systemPromptModal) {
        closeModal();
      }
    };

    // --- Config Editor JavaScript ---

    const CONFIG_SCHEMA = {
      orchestrator: {
        title: 'Orchestrator',
        fields: {
          host: { type: 'text', label: 'Host' },
          port: { type: 'number', label: 'Port' },
          log_level: { type: 'select', label: 'Log Level', options: ['DEBUG', 'INFO', 'WARNING', 'ERROR'] },
          enable_latency_tracking: { type: 'boolean', label: 'Enable Latency Tracking' }
        }
      },
      stt: {
        title: 'STT (Speech-to-Text)',
        fields: {
          provider: { type: 'provider_select', label: 'Provider', providers: ['funasr', 'faster-whisper'] },
          language_code: { type: 'text', label: 'Language Code' },
          sample_rate: { type: 'number', label: 'Sample Rate' }
        },
        provider_fields: {
          'faster-whisper': {
            model_path: { type: 'text', label: 'Model Path' },
            device: { type: 'text', label: 'Device (null for auto)' },
            compute_type: { type: 'text', label: 'Compute Type (null for auto)' }
          },
          'funasr': {
            model_name: { type: 'text', label: 'Model Name' },
            vad_model: { type: 'text', label: 'VAD Model' },
            punc_model: { type: 'text', label: 'Punctuation Model' },
            streaming: {
              type: 'nested',
              label: 'Streaming Settings',
              fields: {
                enabled: { type: 'boolean', label: 'Enabled' },
                vad_chunk_size_ms: { type: 'number', label: 'VAD Chunk Size (ms)' },
                silence_threshold_ms: { type: 'number', label: 'Silence Threshold (ms)' }
              }
            }
          }
        }
      },
      llm: {
        title: 'LLM (Language Model)',
        fields: {
          provider: { type: 'provider_select', label: 'Provider', providers: ['ollama', 'gemini'] }
        },
        provider_fields: {
          gemini: {
            model: { type: 'text', label: 'Model' },
            api_key: { type: 'password', label: 'API Key' }
          },
          ollama: {
            model: { type: 'text', label: 'Model' },
            base_url: { type: 'text', label: 'Base URL' },
            timeout: { type: 'number', label: 'Timeout (s)' },
            disable_thinking: { type: 'boolean', label: 'Disable Thinking' }
          }
        }
      },
      tts: {
        title: 'TTS (Text-to-Speech)',
        fields: {
          provider: { type: 'provider_select', label: 'Provider', providers: ['edge-tts', 'chattts', 'genie-tts', 'elevenlabs'] },
          output_sample_rate: { type: 'number', label: 'Output Sample Rate (null for auto)' }
        },
        provider_fields: {
          'edge-tts': {
            voice: { type: 'text', label: 'Voice' },
            rate: { type: 'text', label: 'Rate' },
            pitch: { type: 'text', label: 'Pitch' }
          },
          'chattts': {
            model_source: { type: 'select', label: 'Model Source', options: ['local', 'huggingface', 'custom'] },
            device: { type: 'text', label: 'Device (null for auto)' }
          },
          'genie-tts': {
            character_name: { type: 'text', label: 'Character Name' },
            onnx_model_dir: { type: 'text', label: 'ONNX Model Dir' },
            language: { type: 'text', label: 'Language' },
            reference_audio_path: { type: 'text', label: 'Ref Audio Path' },
            source_sample_rate: { type: 'number', label: 'Source Sample Rate' }
          },
          'elevenlabs': {
            voice_id: { type: 'text', label: 'Voice ID' },
            stability: { type: 'number', label: 'Stability (0-1)' },
            similarity_boost: { type: 'number', label: 'Similarity Boost (0-1)' }
          }
        }
      },
      ocr: {
        title: 'OCR',
        fields: {
          host: { type: 'text', label: 'Host' },
          port: { type: 'number', label: 'Port' },
          language: { type: 'text', label: 'Language' },
          interval_ms: { type: 'number', label: 'Interval (ms)' }
        }
      },
      audio: {
        title: 'Audio Settings',
        fields: {
          input: {
            type: 'nested',
            label: 'Input Settings',
            fields: {
              sample_rate: { type: 'number', label: 'Sample Rate' },
              channels: { type: 'number', label: 'Channels' },
              device: { type: 'text', label: 'Device Index (null for default)' }
            }
          },
          output: {
            type: 'nested',
            label: 'Output Settings',
            fields: {
              sample_rate: { type: 'number', label: 'Sample Rate' },
              channels: { type: 'number', label: 'Channels' },
              device: { type: 'text', label: 'Device Index (null for default)' }
            }
          },
          silence_threshold_ms: { type: 'number', label: 'Silence Threshold (ms)' },
          vad_min_speech_prob: { type: 'number', label: 'VAD Min Speech Prob (0-1)' }
        }
      },
      bilibili: {
        title: 'Bilibili',
        fields: {
          enabled: { type: 'boolean', label: 'Enabled' },
          room_id: { type: 'number', label: 'Room ID' },
          sessdata: { type: 'password', label: 'SESSDATA' }
        }
      },
      obs: {
        title: 'OBS',
        fields: {
          websocket: {
            type: 'nested',
            label: 'Websocket Settings',
            fields: {
              host: { type: 'text', label: 'Host' },
              port: { type: 'number', label: 'Port' },
              password: { type: 'password', label: 'Password' }
            }
          },
          subtitle_source: { type: 'text', label: 'Subtitle Source Name' }
        }
      },
      services: {
        title: 'Service URLs',
        fields: {
          orchestrator_base_url: { type: 'text', label: 'Orchestrator Base URL' },
          stt_websocket_url: { type: 'text', label: 'STT WebSocket URL' },
          tts_websocket_url: { type: 'text', label: 'TTS WebSocket URL' },
          ocr_websocket_url: { type: 'text', label: 'OCR WebSocket URL' },
          ocr_base_url: { type: 'text', label: 'OCR Base URL' }
        }
      }
    };

    function createFormField(key, field, value, path = []) {
      const fullPath = [...path, key].join('.');
      const group = document.createElement('div');
      group.className = 'config-form-group';
      
      if (field.type === 'nested') {
        const nestedGroup = document.createElement('div');
        nestedGroup.className = 'nested-group';
        const title = document.createElement('div');
        title.className = 'nested-title';
        title.textContent = field.label;
        nestedGroup.appendChild(title);
        
        Object.entries(field.fields).forEach(([subKey, subField]) => {
          const subValue = (value && typeof value === 'object') ? value[subKey] : undefined;
          nestedGroup.appendChild(createFormField(subKey, subField, subValue, [...path, key]));
        });
        return nestedGroup;
      }
      
      const label = document.createElement('label');
      label.className = 'config-label';
      label.textContent = field.label;
      group.appendChild(label);
      
      let input;
      if (field.type === 'select' || field.type === 'provider_select') {
        input = document.createElement('select');
        input.className = 'config-input';
        const options = field.type === 'provider_select' ? field.providers : field.options;
        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt;
          option.textContent = opt;
          if (opt === value) option.selected = true;
          input.appendChild(option);
        });
        
        if (field.type === 'provider_select') {
          input.dataset.isProviderSelect = 'true';
          input.dataset.section = path[0] || key;
        }
      } else if (field.type === 'boolean') {
        group.className = 'config-form-group config-checkbox-group';
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'config-checkbox';
        input.checked = !!value;
        // Swap label and input for checkbox
        group.innerHTML = '';
        group.appendChild(input);
        group.appendChild(label);
      } else {
        input = document.createElement('input');
        input.type = field.type === 'password' ? 'password' : 'text';
        input.className = 'config-input';
        input.value = value === null || value === undefined ? '' : value;
      }
      
      input.dataset.path = fullPath;
      input.name = fullPath;
      group.appendChild(input);
      
      return group;
    }

    function buildAccordion() {
      configAccordion.innerHTML = '';
      
      Object.entries(CONFIG_SCHEMA).forEach(([sectionKey, section]) => {
        const item = document.createElement('div');
        item.className = 'accordion-item';
        
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.textContent = section.title;
        header.onclick = () => {
          item.classList.toggle('active');
        };
        
        const content = document.createElement('div');
        content.className = 'accordion-content';
        content.id = `section-${sectionKey}`;
        
        // Add common fields
        const sectionData = currentConfig[sectionKey] || {};
        Object.entries(section.fields).forEach(([fieldKey, field]) => {
          const fieldElement = createFormField(fieldKey, field, sectionData[fieldKey], [sectionKey]);
          content.appendChild(fieldElement);
          
          if (field.type === 'provider_select') {
            const providerSelect = fieldElement.querySelector('select');
            providerSelect.onchange = (e) => {
              updateProviderFields(sectionKey, e.target.value);
            };
          }
        });
        
        // Add container for provider-specific fields
        if (section.provider_fields) {
          const providerContainer = document.createElement('div');
          providerContainer.className = 'provider-section';
          providerContainer.id = `provider-fields-${sectionKey}`;
          content.appendChild(providerContainer);
          
          const currentProvider = sectionData[section.fields.provider ? 'provider' : '']; // Assumes field named 'provider'
          if (currentProvider) {
            // This will be called after the initial build
          }
        }
        
        item.appendChild(header);
        item.appendChild(content);
        configAccordion.appendChild(item);
      });
    }

    function updateProviderFields(sectionKey, providerKey) {
      const container = document.getElementById(`provider-fields-${sectionKey}`);
      if (!container) return;
      
      container.innerHTML = '';
      const sectionSchema = CONFIG_SCHEMA[sectionKey];
      if (!sectionSchema || !sectionSchema.provider_fields || !sectionSchema.provider_fields[providerKey]) {
        return;
      }
      
      const providerSchema = sectionSchema.provider_fields[providerKey];
      const sectionData = currentConfig[sectionKey] || {};
      const providersData = sectionData.providers || {};
      const providerData = providersData[providerKey] || {};
      
      Object.entries(providerSchema).forEach(([fieldKey, field]) => {
        container.appendChild(createFormField(fieldKey, field, providerData[fieldKey], [sectionKey, 'providers', providerKey]));
      });
    }

    async function loadFullConfig() {
      try {
        const response = await fetch('/ui/config');
        if (!response.ok) throw new Error('Failed to load config');
        currentConfig = await response.json();
        
        buildAccordion();
        
        // Initial provider fields update
        Object.entries(CONFIG_SCHEMA).forEach(([sectionKey, section]) => {
          const providerSelect = document.querySelector(`select[data-is-provider-select="true"][data-section="${sectionKey}"]`);
          if (providerSelect) {
            updateProviderFields(sectionKey, providerSelect.value);
          }
        });
      } catch (e) {
        console.error('Error loading config:', e);
        showConfigStatusMessage('Failed to load configuration', true);
      }
    }

    function getFormValue(path) {
      const input = document.querySelector(`[name="${path}"]`);
      if (!input) return undefined;
      
      if (input.type === 'checkbox') return input.checked;
      if (input.type === 'number') return parseFloat(input.value);
      
      let val = input.value;
      if (val === '' && input.type !== 'password') return null;
      if (!isNaN(val) && val !== '' && input.type !== 'text' && input.type !== 'password') return parseFloat(val);
      
      return val;
    }

    function setDeepValue(obj, path, value) {
      const parts = path.split('.');
      let current = obj;
      for (let i = 0; i < parts.length - 1; i++) {
        const part = parts[i];
        if (!(part in current)) current[part] = {};
        current = current[part];
      }
      current[parts[parts.length - 1]] = value;
    }

    async function saveFullConfig() {
      const newConfig = JSON.parse(JSON.stringify(currentConfig)); // Deep copy to maintain original structure
      
      const allInputs = configAccordion.querySelectorAll('input, select');
      allInputs.forEach(input => {
        const path = input.dataset.path;
        if (!path) return;
        
        let val;
        if (input.type === 'checkbox') {
          val = input.checked;
        } else {
          val = input.value;
          // Try to convert to number if appropriate
          if (input.type === 'number' || (!isNaN(val) && val !== '' && input.type !== 'text' && input.type !== 'password')) {
            val = val.includes('.') ? parseFloat(val) : parseInt(val, 10);
          } else if (val === '' && input.type !== 'password') {
            val = null;
          }
        }
        
        setDeepValue(newConfig, path, val);
      });
      
      configModalSave.disabled = true;
      try {
        const response = await fetch('/ui/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ config: newConfig })
        });
        
        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.detail || 'Failed to save configuration');
        }
        
        showConfigStatusMessage('Configuration saved successfully! Some changes may require a restart.');
        currentConfig = newConfig;
      } catch (e) {
        console.error('Error saving config:', e);
        showConfigStatusMessage(e.message, true);
      } finally {
        configModalSave.disabled = false;
      }
    }

    function showConfigStatusMessage(text, isError = false) {
      configStatusMessage.textContent = text;
      configStatusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
      setTimeout(() => {
        configStatusMessage.className = 'status-message';
      }, 5000);
    }

    function closeConfigModal() {
      configModal.classList.remove('active');
    }

    configBtn.onclick = () => {
      configModal.classList.add('active');
      loadFullConfig();
    };

    configModalClose.onclick = closeConfigModal;
    configModalCancel.onclick = closeConfigModal;
    configModalSave.onclick = saveFullConfig;

    // Close config modal when clicking outside
    configModal.onclick = (e) => {
      if (e.target === configModal) {
        closeConfigModal();
      }
    };

    connect();
  </script>
</body>
</html>
